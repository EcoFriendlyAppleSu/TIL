
---

🍎 프로젝트 관련
→ Json Data 타입 변환에 시간이 많이 소요됐습니다. TestCode 작성 시 org.json Library를 사용해 테스트를 마치고 프로덕트 코드에서 org.json을 지원하지 않아 해결 방법을 찾느라 시간이 걸렸습니다.
→ 따로 의존성을 추가해서 Json 타입 데이터를 핸들링해야하나 생각을 했지만 이미 spring framework안에 존재하는 jackson objectMapper를 통해 해결할 수 있었습니다.
→ Json 데이터를 다룰 때 list, reference type을 사용해야 하는 경우를 알게 되었고 모든 폼을 맞춰서 데이터를 파싱하지 않는 설정도 있다는 것을 알았습니다.

🍎 새로 알게된 사실 혹은 알고 있던 사실에대한 질문, 답변

🍎 What is SaaS(Software-as-a-Service)?
→ SaaS는 클라우드 애플리케이션과 기본 IT infra 및 플랫폼을 인터넷 브라우저를 통해 최송 사용자에게 제공하는 **클라우드 컴퓨팅**형태입니다.
→ SaaS를 사용하면 SW를 영구 구매하거나 온프레미스 IT infra에 투자할 필요가 없기 때문에 사용자의 초기 비용이 줄어듭니다. 그러나 성능은 인터넷 연결 속도에 따라 달라지므로 SaaS 고객은 고속 네트워크 HW에 투자해야 합니다.
→ SaaS Application은 Multi-Tenant Arch를 활용하여 고객 데이터를 격리합니다. SW 업그레이드, 버그 수정 및 기타 일반적인 Application 유지 관리는 SaaS provider에서 수행하고, 사용자는 웹 브라우저를 통해 SW와 상호작용합니다. SaaS 솔루션은 종종 다른 기능에 연결하기 위해 API(ex, Rest, SOAP)를 통해 사용자 정의 통합을 결합합니다.

  ❓ SOAP란 무엇인가요?
  → REST와 같은 온라인 데이터 전송 방식입니다. 둘 다 웹 애플리케이션 간 데이터 통신을 허용하는 API를 구축하는 방법을 정의합니다. SOAP(Simple Object Access Protocal)은 W3C에서 유지관리 하는 공식 프로토콜입니다. REST은 프로토콜이 아닌 점이 차이점입니다.
  → SOAP 방식은 데이터 포맷으로 오직 xml만 허용됩니다.

  ❓ Multi-Tenant란 무엇인가요?
  → Multi-Tenant(=Multitenancy)라는 용어는 SW Arch의 하나를 가리키며, 하나의 SW Instance가 한 대의 서버 위에서 동작하면서 여러 개의 Tenant를 서비스합니다. 여기서 Tenant란 SW Instance에 대해 공통이 되는 특정 접근 권한을 공유하는 사용자들의 그룹입니다.

📖 Real MySQL 8.0
🍎 MySQL Server는 사람의 머리 역할을 담당하는 **MySQL** 엔진과 손발 역할을 담당하는 **Storage** 엔진으로 구분할 수 있습니다.

❓ MySQL Server는 Process 기반이 아닌 Thread 기반으로 작동하며, foreground thread 와 background thread로 나뉩니다. 둘의 차이점은 무엇인가요?

  🍏 foreground thread
  → foreground thread는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리합니다.
  → 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리합니다.

  ❗ MyISAM의 경우엔 디스크 쓰기 작업까지 foreground thread가 처리하지만 InnoDB 테이블은 데이터 버퍼나 캐시까지만 foreground thread가 처리하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 background thread가 처리합니다.

  🍏 background thread
  → MyISAM의 경우에는 해당 사항이 없는 부분이지만 InnoDB는 다음과 같이 여러 작업이 background로 처리된다.
  * Insert Buffer를 병합하는 스레드
  * 로그를 디스크로 기록하는 스레드
  * InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  * 데이터를 버퍼로 읽어 오는 스레드
  * 잠금이나 데드락을 모니터링하는 스레드

  ❗ 사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다. 쓰기 작업을 버퍼링해서 일괄 처리하는 기능을 InnoDB에서 사용한다.

🍎 MySQL에서 사용되는 메모리 공간
  → 글로벌 메모리 영역와 로컬 메모리 영역이 존재합니다.

  🍏 글로벌 메모리 영역
  → 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 OS로부터 할당됩니다. 또한 **모든 스레드에 의해 공유**됩니다.
  * 테이블캐시
  * InnoDB 버퍼 풀
  * InnoDB 어댑터 해시 인덱스
  * InnoDB 리두 로그 버퍼

  🍏 글로벌 메모리 영역
  → MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역입니다. 절대 공유되지 않는다는 특징이 존재합니다.
  * 정렬 버퍼
  * 조인 버퍼
  * 바이너리 로그 캐시
  * 네트워크 버퍼

🍎 MySQL의 플러그인 모델
  → 플러그인으로 만들어진 것들을 갈아 끼우듯이 사용할 수 있는 구조입니다.

  ❓ 플러그인을 사용해서 얻을 수 있는 장점이 무엇인가요?
  → 전문 검색 엔진을 위한 검색어 파서도 플러그인 형태로 개발해서 사용할 수 있으며, 사용자의 입맛에 맞춰 개발도 가능합니다.
  ❓ 단점은 없나요?
  * 플러그인끼리는 통신할 수 없습니다.
  * 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않습니다.
  * 상호 의존 관계를 설정할 수 없어서 초기화가 어렵습니다.
  → 위 문제를 해결하기 위해 MySQL 8.0 부터는 **Component Arch** 가 지원됩니다.

🍎 MySQL 쿼리 실행 구조
  1. 쿼리 파서 : 쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미합니다.
  2. 전처리기 : 쿼리 문자에 구조적인 문제점이 있는지 확인합니다.
  3. 옵티마이저 : 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당하며, DBMS의 두뇌에 해당됩니다.
  4. 실행 엔진 : 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행합니다.
  5. 핸들러 : 핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당합니다.

❓ MySQL thread pool의 목적은 무엇인가요?
  → thread pool은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적입니다.

  ❓ thread pool에 thread 개수는 어느정도가 괜찮을까요?
  → 일반적으로 CPU 코어의 개수와 맞추는 것이 CPU 프로세서 친화도를 높이는 데 좋다. 개수가 너무 많다면 스케줄링해야 할 스레드가 많아져서 thread pool이 비효율적으로 작동할 수 있다.
  → 모든 thread가 일을 처리하고 있다면 thread pool에선 두 가지 선택을 할 수 있다.
  1. 해당 스레드 그룹에 새로운 작업을 추가한다.
  2. 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부 판단
  +) 또한, 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다.

🍎 메타 데이터 관리
  → MySQL 8.0 부터는 메타데이터에 관한 정보를 InnoDB의 테이블에 저장하도록 개선됐다.

  ❓ InnoDB에서 관리함에 얻을 수 있는 장점이 있나요?
  → 스키마 변경 작업 중간에 MySQL 서버가 비정상적으로 종료된다고 하더라도 스키마 변경이 성공 또는 완정한 실패로 정리된다. 이는 Transaction을 사용함에 얻을 수 있는 장점이다.

🍎 InnoDB Storage Arch
  → InnoDB는 레코드 기반 잠금을 제공합니다. 이 때문에 동시성 처리가 가능하고 안정적이며 성능이 뛰어납니다.

  ❗ InnoDB는 PK에 의한 클러스터링을 제공해 Ragne Scan이 성능이 좋습니다.

  ❓ 외래 키를 지원합니다. MyISAM이나 Memory 테이블에선 사용할 수 없습니다. 외래 키를 사용하면 얻을 수 있는 장점과 단점은 어떤게 있을까요?
  🍏 외래 키 사용 장점
  → 참조 무결성을 유지할 수 있습니다.
  🍏 외래 키 사용 단점
  → 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파됩니다. 이는 데트락이 발생할 수 있음으로 외래 키의 존재에 주의가 필요합니다.

---
📚 Reference
[외래키의 장점과 단점, 비교](https://velog.io/@subutai/매일-2day)
[What is SaaS?](https://www.redhat.com/ko/topics/cloud-computing/what-is-saas
[REST, SOAP 차이](https://www.redhat.com/ko/topics/integration/whats-the-difference-between-soap-rest)
